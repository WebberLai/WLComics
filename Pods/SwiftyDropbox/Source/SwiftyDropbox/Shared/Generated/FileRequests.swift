///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the file_requests namespace
open class FileRequests {
    /// There is an error accessing the file requests functionality.
    public enum GeneralFileRequestsError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GeneralFileRequestsErrorSerializer().serialize(self)))"
        }
    }
    open class GeneralFileRequestsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GeneralFileRequestsError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GeneralFileRequestsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return GeneralFileRequestsError.disabledForTeam
                        case "other":
                            return GeneralFileRequestsError.other
                        default:
                            return GeneralFileRequestsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There was an error counting the file requests.
    public enum CountFileRequestsError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CountFileRequestsErrorSerializer().serialize(self)))"
        }
    }
    open class CountFileRequestsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CountFileRequestsError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CountFileRequestsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return CountFileRequestsError.disabledForTeam
                        case "other":
                            return CountFileRequestsError.other
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for count.
    open class CountFileRequestsResult: CustomStringConvertible {
        /// The number file requests owner by this user.
        public let fileRequestCount: UInt64
        public init(fileRequestCount: UInt64) {
            comparableValidator()(fileRequestCount)
            self.fileRequestCount = fileRequestCount
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CountFileRequestsResultSerializer().serialize(self)))"
        }
    }
    open class CountFileRequestsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CountFileRequestsResult) -> JSON {
            let output = [ 
            "file_request_count": Serialization._UInt64Serializer.serialize(value.fileRequestCount),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CountFileRequestsResult {
            switch json {
                case .dictionary(let dict):
                    let fileRequestCount = Serialization._UInt64Serializer.deserialize(dict["file_request_count"] ?? .null)
                    return CountFileRequestsResult(fileRequestCount: fileRequestCount)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for create.
    open class CreateFileRequestArgs: CustomStringConvertible {
        /// The title of the file request. Must not be empty.
        public let title: String
        /// The path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder
        /// permission, this will be relative to the app folder.
        public let destination: String
        /// The deadline for the file request. Deadlines can only be set by Professional and Business accounts.
        public let deadline: FileRequests.FileRequestDeadline?
        /// Whether or not the file request should be open. If the file request is closed, it will not accept any file
        /// submissions, but it can be opened later.
        public let open: Bool
        public init(title: String, destination: String, deadline: FileRequests.FileRequestDeadline? = nil, open: Bool = true) {
            stringValidator(minLength: 1)(title)
            self.title = title
            stringValidator(pattern: "/(.|[\\r\\n])*")(destination)
            self.destination = destination
            self.deadline = deadline
            self.open = open
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class CreateFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFileRequestArgs) -> JSON {
            let output = [ 
            "title": Serialization._StringSerializer.serialize(value.title),
            "destination": Serialization._StringSerializer.serialize(value.destination),
            "deadline": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(value.deadline),
            "open": Serialization._BoolSerializer.serialize(value.open),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .null)
                    let destination = Serialization._StringSerializer.deserialize(dict["destination"] ?? .null)
                    let deadline = NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                    let open = Serialization._BoolSerializer.deserialize(dict["open"] ?? .number(1))
                    return CreateFileRequestArgs(title: title, destination: destination, deadline: deadline, open: open)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There is an error with the file request.
    public enum FileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class FileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> FileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return FileRequestError.disabledForTeam
                        case "other":
                            return FileRequestError.other
                        case "not_found":
                            return FileRequestError.notFound
                        case "not_a_folder":
                            return FileRequestError.notAFolder
                        case "app_lacks_access":
                            return FileRequestError.appLacksAccess
                        case "no_permission":
                            return FileRequestError.noPermission
                        case "email_unverified":
                            return FileRequestError.emailUnverified
                        case "validation_error":
                            return FileRequestError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There was an error creating the file request.
    public enum CreateFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError
        /// File requests are not available on the specified folder.
        case invalidLocation
        /// The user has reached the rate limit for creating file requests. The limit is currently 100 file requests per
        /// day.
        case rateLimit

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CreateFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
                case .invalidLocation:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_location")
                    return .dictionary(d)
                case .rateLimit:
                    var d = [String: JSON]()
                    d[".tag"] = .str("rate_limit")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return CreateFileRequestError.disabledForTeam
                        case "other":
                            return CreateFileRequestError.other
                        case "not_found":
                            return CreateFileRequestError.notFound
                        case "not_a_folder":
                            return CreateFileRequestError.notAFolder
                        case "app_lacks_access":
                            return CreateFileRequestError.appLacksAccess
                        case "no_permission":
                            return CreateFileRequestError.noPermission
                        case "email_unverified":
                            return CreateFileRequestError.emailUnverified
                        case "validation_error":
                            return CreateFileRequestError.validationError
                        case "invalid_location":
                            return CreateFileRequestError.invalidLocation
                        case "rate_limit":
                            return CreateFileRequestError.rateLimit
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There was an error deleting all closed file requests.
    public enum DeleteAllClosedFileRequestsError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteAllClosedFileRequestsErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteAllClosedFileRequestsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteAllClosedFileRequestsError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteAllClosedFileRequestsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return DeleteAllClosedFileRequestsError.disabledForTeam
                        case "other":
                            return DeleteAllClosedFileRequestsError.other
                        case "not_found":
                            return DeleteAllClosedFileRequestsError.notFound
                        case "not_a_folder":
                            return DeleteAllClosedFileRequestsError.notAFolder
                        case "app_lacks_access":
                            return DeleteAllClosedFileRequestsError.appLacksAccess
                        case "no_permission":
                            return DeleteAllClosedFileRequestsError.noPermission
                        case "email_unverified":
                            return DeleteAllClosedFileRequestsError.emailUnverified
                        case "validation_error":
                            return DeleteAllClosedFileRequestsError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for deleteAllClosed.
    open class DeleteAllClosedFileRequestsResult: CustomStringConvertible {
        /// The file requests deleted for this user.
        public let fileRequests: Array<FileRequests.FileRequest>
        public init(fileRequests: Array<FileRequests.FileRequest>) {
            self.fileRequests = fileRequests
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteAllClosedFileRequestsResultSerializer().serialize(self)))"
        }
    }
    open class DeleteAllClosedFileRequestsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteAllClosedFileRequestsResult) -> JSON {
            let output = [ 
            "file_requests": ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteAllClosedFileRequestsResult {
            switch json {
                case .dictionary(let dict):
                    let fileRequests = ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                    return DeleteAllClosedFileRequestsResult(fileRequests: fileRequests)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for delete.
    open class DeleteFileRequestArgs: CustomStringConvertible {
        /// List IDs of the file requests to delete.
        public let ids: Array<String>
        public init(ids: Array<String>) {
            arrayValidator(itemValidator: stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+"))(ids)
            self.ids = ids
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class DeleteFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteFileRequestArgs) -> JSON {
            let output = [ 
            "ids": ArraySerializer(Serialization._StringSerializer).serialize(value.ids),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let ids = ArraySerializer(Serialization._StringSerializer).deserialize(dict["ids"] ?? .null)
                    return DeleteFileRequestArgs(ids: ids)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There was an error deleting these file requests.
    public enum DeleteFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError
        /// One or more file requests currently open.
        case fileRequestOpen

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
                case .fileRequestOpen:
                    var d = [String: JSON]()
                    d[".tag"] = .str("file_request_open")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return DeleteFileRequestError.disabledForTeam
                        case "other":
                            return DeleteFileRequestError.other
                        case "not_found":
                            return DeleteFileRequestError.notFound
                        case "not_a_folder":
                            return DeleteFileRequestError.notAFolder
                        case "app_lacks_access":
                            return DeleteFileRequestError.appLacksAccess
                        case "no_permission":
                            return DeleteFileRequestError.noPermission
                        case "email_unverified":
                            return DeleteFileRequestError.emailUnverified
                        case "validation_error":
                            return DeleteFileRequestError.validationError
                        case "file_request_open":
                            return DeleteFileRequestError.fileRequestOpen
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for delete.
    open class DeleteFileRequestsResult: CustomStringConvertible {
        /// The file requests deleted by the request.
        public let fileRequests: Array<FileRequests.FileRequest>
        public init(fileRequests: Array<FileRequests.FileRequest>) {
            self.fileRequests = fileRequests
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(DeleteFileRequestsResultSerializer().serialize(self)))"
        }
    }
    open class DeleteFileRequestsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteFileRequestsResult) -> JSON {
            let output = [ 
            "file_requests": ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteFileRequestsResult {
            switch json {
                case .dictionary(let dict):
                    let fileRequests = ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                    return DeleteFileRequestsResult(fileRequests: fileRequests)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// A file request https://www.dropbox.com/help/9090 for receiving files into the user's Dropbox account.
    open class FileRequest: CustomStringConvertible {
        /// The ID of the file request.
        public let id: String
        /// The URL of the file request.
        public let url: String
        /// The title of the file request.
        public let title: String
        /// The path of the folder in the Dropbox where uploaded files will be sent. This can be null if the destination
        /// was removed. For apps with the app folder permission, this will be relative to the app folder.
        public let destination: String?
        /// When this file request was created.
        public let created: Date
        /// The deadline for this file request. Only set if the request has a deadline.
        public let deadline: FileRequests.FileRequestDeadline?
        /// Whether or not the file request is open. If the file request is closed, it will not accept any more file
        /// submissions.
        public let isOpen: Bool
        /// The number of files this file request has received.
        public let fileCount: Int64
        public init(id: String, url: String, title: String, created: Date, isOpen: Bool, fileCount: Int64, destination: String? = nil, deadline: FileRequests.FileRequestDeadline? = nil) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
            stringValidator(minLength: 1)(url)
            self.url = url
            stringValidator(minLength: 1)(title)
            self.title = title
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(destination)
            self.destination = destination
            self.created = created
            self.deadline = deadline
            self.isOpen = isOpen
            comparableValidator()(fileCount)
            self.fileCount = fileCount
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestSerializer().serialize(self)))"
        }
    }
    open class FileRequestSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequest) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "url": Serialization._StringSerializer.serialize(value.url),
            "title": Serialization._StringSerializer.serialize(value.title),
            "created": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.created),
            "is_open": Serialization._BoolSerializer.serialize(value.isOpen),
            "file_count": Serialization._Int64Serializer.serialize(value.fileCount),
            "destination": NullableSerializer(Serialization._StringSerializer).serialize(value.destination),
            "deadline": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(value.deadline),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequest {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .null)
                    let created = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["created"] ?? .null)
                    let isOpen = Serialization._BoolSerializer.deserialize(dict["is_open"] ?? .null)
                    let fileCount = Serialization._Int64Serializer.deserialize(dict["file_count"] ?? .null)
                    let destination = NullableSerializer(Serialization._StringSerializer).deserialize(dict["destination"] ?? .null)
                    let deadline = NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(dict["deadline"] ?? .null)
                    return FileRequest(id: id, url: url, title: title, created: created, isOpen: isOpen, fileCount: fileCount, destination: destination, deadline: deadline)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The FileRequestDeadline struct
    open class FileRequestDeadline: CustomStringConvertible {
        /// The deadline for this file request.
        public let deadline: Date
        /// If set, allow uploads after the deadline has passed. These     uploads will be marked overdue.
        public let allowLateUploads: FileRequests.GracePeriod?
        public init(deadline: Date, allowLateUploads: FileRequests.GracePeriod? = nil) {
            self.deadline = deadline
            self.allowLateUploads = allowLateUploads
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(FileRequestDeadlineSerializer().serialize(self)))"
        }
    }
    open class FileRequestDeadlineSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileRequestDeadline) -> JSON {
            let output = [ 
            "deadline": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.deadline),
            "allow_late_uploads": NullableSerializer(FileRequests.GracePeriodSerializer()).serialize(value.allowLateUploads),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileRequestDeadline {
            switch json {
                case .dictionary(let dict):
                    let deadline = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["deadline"] ?? .null)
                    let allowLateUploads = NullableSerializer(FileRequests.GracePeriodSerializer()).deserialize(dict["allow_late_uploads"] ?? .null)
                    return FileRequestDeadline(deadline: deadline, allowLateUploads: allowLateUploads)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for get.
    open class GetFileRequestArgs: CustomStringConvertible {
        /// The ID of the file request to retrieve.
        public let id: String
        public init(id: String) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class GetFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileRequestArgs) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    return GetFileRequestArgs(id: id)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There was an error retrieving the specified file request.
    public enum GetFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class GetFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return GetFileRequestError.disabledForTeam
                        case "other":
                            return GetFileRequestError.other
                        case "not_found":
                            return GetFileRequestError.notFound
                        case "not_a_folder":
                            return GetFileRequestError.notAFolder
                        case "app_lacks_access":
                            return GetFileRequestError.appLacksAccess
                        case "no_permission":
                            return GetFileRequestError.noPermission
                        case "email_unverified":
                            return GetFileRequestError.emailUnverified
                        case "validation_error":
                            return GetFileRequestError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GracePeriod union
    public enum GracePeriod: CustomStringConvertible {
        /// An unspecified error.
        case oneDay
        /// An unspecified error.
        case twoDays
        /// An unspecified error.
        case sevenDays
        /// An unspecified error.
        case thirtyDays
        /// An unspecified error.
        case always
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GracePeriodSerializer().serialize(self)))"
        }
    }
    open class GracePeriodSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GracePeriod) -> JSON {
            switch value {
                case .oneDay:
                    var d = [String: JSON]()
                    d[".tag"] = .str("one_day")
                    return .dictionary(d)
                case .twoDays:
                    var d = [String: JSON]()
                    d[".tag"] = .str("two_days")
                    return .dictionary(d)
                case .sevenDays:
                    var d = [String: JSON]()
                    d[".tag"] = .str("seven_days")
                    return .dictionary(d)
                case .thirtyDays:
                    var d = [String: JSON]()
                    d[".tag"] = .str("thirty_days")
                    return .dictionary(d)
                case .always:
                    var d = [String: JSON]()
                    d[".tag"] = .str("always")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GracePeriod {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "one_day":
                            return GracePeriod.oneDay
                        case "two_days":
                            return GracePeriod.twoDays
                        case "seven_days":
                            return GracePeriod.sevenDays
                        case "thirty_days":
                            return GracePeriod.thirtyDays
                        case "always":
                            return GracePeriod.always
                        case "other":
                            return GracePeriod.other
                        default:
                            return GracePeriod.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Arguments for listV2.
    open class ListFileRequestsArg: CustomStringConvertible {
        /// The maximum number of file requests that should be returned per request.
        public let limit: UInt64
        public init(limit: UInt64 = 1000) {
            comparableValidator()(limit)
            self.limit = limit
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsArgSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsArg) -> JSON {
            let output = [ 
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsArg {
            switch json {
                case .dictionary(let dict):
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .number(1000))
                    return ListFileRequestsArg(limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ListFileRequestsContinueArg struct
    open class ListFileRequestsContinueArg: CustomStringConvertible {
        /// The cursor returned by the previous API call specified in the endpoint description.
        public let cursor: String
        public init(cursor: String) {
            stringValidator()(cursor)
            self.cursor = cursor
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFileRequestsContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// There was an error retrieving the file requests.
    public enum ListFileRequestsContinueError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// The cursor is invalid.
        case invalidCursor

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsContinueError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .invalidCursor:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return ListFileRequestsContinueError.disabledForTeam
                        case "other":
                            return ListFileRequestsContinueError.other
                        case "invalid_cursor":
                            return ListFileRequestsContinueError.invalidCursor
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There was an error retrieving the file requests.
    public enum ListFileRequestsError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsErrorSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return ListFileRequestsError.disabledForTeam
                        case "other":
                            return ListFileRequestsError.other
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// Result for list_.
    open class ListFileRequestsResult: CustomStringConvertible {
        /// The file requests owned by this user. Apps with the app folder permission will only see file requests in
        /// their app folder.
        public let fileRequests: Array<FileRequests.FileRequest>
        public init(fileRequests: Array<FileRequests.FileRequest>) {
            self.fileRequests = fileRequests
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsResultSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsResult) -> JSON {
            let output = [ 
            "file_requests": ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsResult {
            switch json {
                case .dictionary(let dict):
                    let fileRequests = ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                    return ListFileRequestsResult(fileRequests: fileRequests)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Result for listV2 and listContinue.
    open class ListFileRequestsV2Result: CustomStringConvertible {
        /// The file requests owned by this user. Apps with the app folder permission will only see file requests in
        /// their app folder.
        public let fileRequests: Array<FileRequests.FileRequest>
        /// Pass the cursor into listContinue to obtain additional file requests.
        public let cursor: String
        /// Is true if there are additional file requests that have not been returned yet. An additional call to
        /// :route:list/continue` can retrieve them.
        public let hasMore: Bool
        public init(fileRequests: Array<FileRequests.FileRequest>, cursor: String, hasMore: Bool) {
            self.fileRequests = fileRequests
            stringValidator()(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ListFileRequestsV2ResultSerializer().serialize(self)))"
        }
    }
    open class ListFileRequestsV2ResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFileRequestsV2Result) -> JSON {
            let output = [ 
            "file_requests": ArraySerializer(FileRequests.FileRequestSerializer()).serialize(value.fileRequests),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFileRequestsV2Result {
            switch json {
                case .dictionary(let dict):
                    let fileRequests = ArraySerializer(FileRequests.FileRequestSerializer()).deserialize(dict["file_requests"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return ListFileRequestsV2Result(fileRequests: fileRequests, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Arguments for update.
    open class UpdateFileRequestArgs: CustomStringConvertible {
        /// The ID of the file request to update.
        public let id: String
        /// The new title of the file request. Must not be empty.
        public let title: String?
        /// The new path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder
        /// permission, this will be relative to the app folder.
        public let destination: String?
        /// The new deadline for the file request. Deadlines can only be set by Professional and Business accounts.
        public let deadline: FileRequests.UpdateFileRequestDeadline
        /// Whether to set this file request as open or closed.
        public let open: Bool?
        public init(id: String, title: String? = nil, destination: String? = nil, deadline: FileRequests.UpdateFileRequestDeadline = .noUpdate, open: Bool? = nil) {
            stringValidator(minLength: 1, pattern: "[-_0-9a-zA-Z]+")(id)
            self.id = id
            nullableValidator(stringValidator(minLength: 1))(title)
            self.title = title
            nullableValidator(stringValidator(pattern: "/(.|[\\r\\n])*"))(destination)
            self.destination = destination
            self.deadline = deadline
            self.open = open
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileRequestArgsSerializer().serialize(self)))"
        }
    }
    open class UpdateFileRequestArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileRequestArgs) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "title": NullableSerializer(Serialization._StringSerializer).serialize(value.title),
            "destination": NullableSerializer(Serialization._StringSerializer).serialize(value.destination),
            "deadline": FileRequests.UpdateFileRequestDeadlineSerializer().serialize(value.deadline),
            "open": NullableSerializer(Serialization._BoolSerializer).serialize(value.open),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFileRequestArgs {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .null)
                    let title = NullableSerializer(Serialization._StringSerializer).deserialize(dict["title"] ?? .null)
                    let destination = NullableSerializer(Serialization._StringSerializer).deserialize(dict["destination"] ?? .null)
                    let deadline = FileRequests.UpdateFileRequestDeadlineSerializer().deserialize(dict["deadline"] ?? FileRequests.UpdateFileRequestDeadlineSerializer().serialize(.noUpdate))
                    let open = NullableSerializer(Serialization._BoolSerializer).deserialize(dict["open"] ?? .null)
                    return UpdateFileRequestArgs(id: id, title: title, destination: destination, deadline: deadline, open: open)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateFileRequestDeadline union
    public enum UpdateFileRequestDeadline: CustomStringConvertible {
        /// Do not change the file request's deadline.
        case noUpdate
        /// If null, the file request's deadline is cleared.
        case update(FileRequests.FileRequestDeadline?)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileRequestDeadlineSerializer().serialize(self)))"
        }
    }
    open class UpdateFileRequestDeadlineSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileRequestDeadline) -> JSON {
            switch value {
                case .noUpdate:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_update")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFileRequestDeadline {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "no_update":
                            return UpdateFileRequestDeadline.noUpdate
                        case "update":
                            let v = NullableSerializer(FileRequests.FileRequestDeadlineSerializer()).deserialize(d["update"] ?? .null)
                            return UpdateFileRequestDeadline.update(v)
                        case "other":
                            return UpdateFileRequestDeadline.other
                        default:
                            return UpdateFileRequestDeadline.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// There is an error updating the file request.
    public enum UpdateFileRequestError: CustomStringConvertible {
        /// This user's Dropbox Business team doesn't allow file requests.
        case disabledForTeam
        /// An unspecified error.
        case other
        /// This file request ID was not found.
        case notFound
        /// The specified path is not a folder.
        case notAFolder
        /// This file request is not accessible to this app. Apps with the app folder permission can only access file
        /// requests in their app folder.
        case appLacksAccess
        /// This user doesn't have permission to access or modify this file request.
        case noPermission
        /// This user's email address is not verified. File requests are only available on accounts with a verified
        /// email address. Users can verify their email address here https://www.dropbox.com/help/317.
        case emailUnverified
        /// There was an error validating the request. For example, the title was invalid, or there were disallowed
        /// characters in the destination path.
        case validationError

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateFileRequestErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateFileRequestErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFileRequestError) -> JSON {
            switch value {
                case .disabledForTeam:
                    var d = [String: JSON]()
                    d[".tag"] = .str("disabled_for_team")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notAFolder:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_a_folder")
                    return .dictionary(d)
                case .appLacksAccess:
                    var d = [String: JSON]()
                    d[".tag"] = .str("app_lacks_access")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String: JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String: JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .validationError:
                    var d = [String: JSON]()
                    d[".tag"] = .str("validation_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFileRequestError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "disabled_for_team":
                            return UpdateFileRequestError.disabledForTeam
                        case "other":
                            return UpdateFileRequestError.other
                        case "not_found":
                            return UpdateFileRequestError.notFound
                        case "not_a_folder":
                            return UpdateFileRequestError.notAFolder
                        case "app_lacks_access":
                            return UpdateFileRequestError.appLacksAccess
                        case "no_permission":
                            return UpdateFileRequestError.noPermission
                        case "email_unverified":
                            return UpdateFileRequestError.emailUnverified
                        case "validation_error":
                            return UpdateFileRequestError.validationError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let count = Route(
        name: "count",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.CountFileRequestsResultSerializer(),
        errorSerializer: FileRequests.CountFileRequestsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let create = Route(
        name: "create",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.CreateFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.CreateFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let delete = Route(
        name: "delete",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.DeleteFileRequestArgsSerializer(),
        responseSerializer: FileRequests.DeleteFileRequestsResultSerializer(),
        errorSerializer: FileRequests.DeleteFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let deleteAllClosed = Route(
        name: "delete_all_closed",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.DeleteAllClosedFileRequestsResultSerializer(),
        errorSerializer: FileRequests.DeleteAllClosedFileRequestsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let get = Route(
        name: "get",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.GetFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.GetFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listV2 = Route(
        name: "list",
        version: 2,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.ListFileRequestsArgSerializer(),
        responseSerializer: FileRequests.ListFileRequestsV2ResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let list_ = Route(
        name: "list",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: Serialization._VoidSerializer,
        responseSerializer: FileRequests.ListFileRequestsResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let listContinue = Route(
        name: "list/continue",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.ListFileRequestsContinueArgSerializer(),
        responseSerializer: FileRequests.ListFileRequestsV2ResultSerializer(),
        errorSerializer: FileRequests.ListFileRequestsContinueErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
    static let update = Route(
        name: "update",
        version: 1,
        namespace: "file_requests",
        deprecated: false,
        argSerializer: FileRequests.UpdateFileRequestArgsSerializer(),
        responseSerializer: FileRequests.FileRequestSerializer(),
        errorSerializer: FileRequests.UpdateFileRequestErrorSerializer(),
        attrs: ["host": "api",
                "style": "rpc"]
    )
}
